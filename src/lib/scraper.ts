import { mkdir, rename, writeFile, rm, stat, readdir } from 'fs/promises';
import { join, dirname, extname, basename } from 'path';
import { NFO_GENERATOR, MEDIA_PATHS } from './config';
import { getTVDetails, getMovieDetails, getSeasonDetails, getPosterUrl, getBackdropUrl, type TMDBShowDetails, type TMDBMovieDetails } from './tmdb';

// Generate tvshow.nfo
export function generateTVShowNFO(show: TMDBShowDetails): string {
  const now = new Date().toISOString().slice(0, 16).replace('T', ' ');
  return `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by ${NFO_GENERATOR} at ${now} -->
<tvshow>
  <title>${escapeXml(show.name)}</title>
  <originaltitle>${escapeXml(show.original_name)}</originaltitle>
  <year>${show.first_air_date?.split('-')[0] || ''}</year>
  <premiered>${show.first_air_date || ''}</premiered>
  <plot>${escapeXml(show.overview)}</plot>
  <tmdbid>${show.id}</tmdbid>
  <generator>${NFO_GENERATOR}</generator>
</tvshow>
`;
}

// Generate episode.nfo
export function generateEpisodeNFO(
  showTitle: string,
  tmdbId: number,
  season: number,
  episode: number,
  title: string,
  aired: string,
  plot: string
): string {
  const now = new Date().toISOString().slice(0, 16).replace('T', ' ');
  return `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by ${NFO_GENERATOR} at ${now} -->
<episodedetails>
  <title>${escapeXml(title)}</title>
  <season>${season}</season>
  <episode>${episode}</episode>
  <aired>${aired}</aired>
  <plot>${escapeXml(plot)}</plot>
  <showtitle>${escapeXml(showTitle)}</showtitle>
  <tmdbid>${tmdbId}</tmdbid>
  <generator>${NFO_GENERATOR}</generator>
</episodedetails>
`;
}

// Generate movie.nfo
export function generateMovieNFO(movie: TMDBMovieDetails): string {
  const now = new Date().toISOString().slice(0, 16).replace('T', ' ');
  return `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by ${NFO_GENERATOR} at ${now} -->
<movie>
  <title>${escapeXml(movie.title)}</title>
  <originaltitle>${escapeXml(movie.original_title)}</originaltitle>
  <year>${movie.release_date?.split('-')[0] || ''}</year>
  <premiered>${movie.release_date || ''}</premiered>
  <plot>${escapeXml(movie.overview)}</plot>
  <runtime>${movie.runtime || ''}</runtime>
  <tmdbid>${movie.id}</tmdbid>
  <generator>${NFO_GENERATOR}</generator>
</movie>
`;
}

function escapeXml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

// Download image
async function downloadImage(url: string, destPath: string): Promise<boolean> {
  try {
    const response = await fetch(url);
    if (!response.ok) return false;
    
    const buffer = await response.arrayBuffer();
    await writeFile(destPath, Buffer.from(buffer));
    return true;
  } catch (error) {
    console.error('Download error:', error);
    return false;
  }
}

// Process TV show
export async function processTVShow(
  sourcePath: string,
  showName: string,
  tmdbId: number,
  season: number,
  episodes: { source: string; episode: number; episodeEnd?: number }[],
  language = 'zh-CN'
): Promise<{ success: boolean; message: string; destPath?: string }> {
  try {
    // Get show details
    const show = await getTVDetails(tmdbId, language);
    if (!show) {
      return { success: false, message: 'Failed to get show details from TMDB' };
    }
    
    // Create destination directory
    const showDir = join(MEDIA_PATHS.tv, showName);
    const seasonDir = join(showDir, `Season ${season.toString().padStart(2, '0')}`);
    await mkdir(seasonDir, { recursive: true });
    
    // Write tvshow.nfo
    const tvshowNfo = generateTVShowNFO(show);
    await writeFile(join(showDir, 'tvshow.nfo'), tvshowNfo, 'utf-8');
    
    // Download poster and fanart
    const posterUrl = getPosterUrl(show.poster_path, 'original');
    const backdropUrl = getBackdropUrl(show.backdrop_path, 'original');
    if (posterUrl) await downloadImage(posterUrl, join(showDir, 'poster.jpg'));
    if (backdropUrl) await downloadImage(backdropUrl, join(showDir, 'fanart.jpg'));
    
    // Get season episodes for metadata
    const seasonEpisodes = await getSeasonDetails(tmdbId, season, language);
    
    // Process each episode
    for (const ep of episodes) {
      const ext = extname(ep.source);
      let epStr = `E${ep.episode.toString().padStart(2, '0')}`;
      if (ep.episodeEnd && ep.episodeEnd !== ep.episode) {
        epStr += `E${ep.episodeEnd.toString().padStart(2, '0')}`;
      }
      const destName = `${showName} - S${season.toString().padStart(2, '0')}${epStr}${ext}`;
      const destPath = join(seasonDir, destName);
      
      // Move file
      await rename(ep.source, destPath);
      
      // Write episode NFO
      const epData = seasonEpisodes.find(e => e.episode_number === ep.episode);
      if (epData) {
        const epNfo = generateEpisodeNFO(
          show.name,
          tmdbId,
          season,
          ep.episode,
          epData.name,
          epData.air_date,
          epData.overview
        );
        await writeFile(destPath.replace(ext, '.nfo'), epNfo, 'utf-8');
      }
      
      // Move related subtitle files
      const srcDir = dirname(ep.source);
      const srcName = basename(ep.source, ext);
      for (const subExt of ['.srt', '.ass', '.ssa', '.sub']) {
        const subPath = join(srcDir, srcName + subExt);
        try {
          await rename(subPath, join(seasonDir, destName.replace(ext, subExt)));
        } catch {}
      }
    }
    
    // Clean up empty source directories
    try {
      const srcDir = dirname(sourcePath);
      await rm(srcDir, { recursive: true });
    } catch {}
    
    return { success: true, message: `Successfully processed ${episodes.length} episodes`, destPath: seasonDir };
  } catch (error) {
    console.error('Process TV show error:', error);
    return { success: false, message: String(error) };
  }
}

// Process movie
export async function processMovie(
  sourcePath: string,
  tmdbId: number,
  language = 'zh-CN'
): Promise<{ success: boolean; message: string; destPath?: string }> {
  try {
    // Get movie details
    const movie = await getMovieDetails(tmdbId, language);
    if (!movie) {
      return { success: false, message: 'Failed to get movie details from TMDB' };
    }
    
    // Create destination directory
    const year = movie.release_date?.split('-')[0] || '';
    const folderName = year ? `${movie.title} (${year})` : movie.title;
    const movieDir = join(MEDIA_PATHS.movies, folderName);
    await mkdir(movieDir, { recursive: true });
    
    // Move file
    const ext = extname(sourcePath);
    const destPath = join(movieDir, `${folderName}${ext}`);
    await rename(sourcePath, destPath);
    
    // Write movie.nfo
    const movieNfo = generateMovieNFO(movie);
    await writeFile(destPath.replace(ext, '.nfo'), movieNfo, 'utf-8');
    
    // Download poster and fanart
    const posterUrl = getPosterUrl(movie.poster_path, 'original');
    const backdropUrl = getBackdropUrl(movie.backdrop_path, 'original');
    if (posterUrl) await downloadImage(posterUrl, join(movieDir, 'poster.jpg'));
    if (backdropUrl) await downloadImage(backdropUrl, join(movieDir, 'fanart.jpg'));
    
    // Move related subtitle files
    const srcDir = dirname(sourcePath);
    const srcName = basename(sourcePath, ext);
    for (const subExt of ['.srt', '.ass', '.ssa', '.sub']) {
      const subPath = join(srcDir, srcName + subExt);
      try {
        await rename(subPath, join(movieDir, `${folderName}${subExt}`));
      } catch {}
    }
    
    // Clean up empty source directory
    try {
      await rm(srcDir, { recursive: true });
    } catch {}
    
    return { success: true, message: `Successfully processed movie: ${movie.title}`, destPath: movieDir };
  } catch (error) {
    console.error('Process movie error:', error);
    return { success: false, message: String(error) };
  }
}

// Refresh metadata only (don't move files)
// For TV: if season is not provided, path should be the show root directory
// If season is provided, path should be a file path within Season XX directory
export async function refreshMetadata(
  kind: 'tv' | 'movie',
  path: string,
  tmdbId: number,
  season?: number,
  episode?: number,
  language = 'zh-CN'
): Promise<{ success: boolean; message: string }> {
  try {
    if (kind === 'tv') {
      const show = await getTVDetails(tmdbId, language);
      if (!show) return { success: false, message: 'Failed to get show details' };
      
      // Determine show directory
      let showDir: string;
      if (season) {
        // Path is within Season XX, go up two levels
        showDir = dirname(dirname(path));
      } else {
        // Path is the show root directory itself
        showDir = path;
      }
      
      // Update tvshow.nfo
      const tvshowNfo = generateTVShowNFO(show);
      await writeFile(join(showDir, 'tvshow.nfo'), tvshowNfo, 'utf-8');
      
      // Download poster/fanart if missing
      const posterUrl = getPosterUrl(show.poster_path, 'original');
      const backdropUrl = getBackdropUrl(show.backdrop_path, 'original');
      if (posterUrl) await downloadImage(posterUrl, join(showDir, 'poster.jpg'));
      if (backdropUrl) await downloadImage(backdropUrl, join(showDir, 'fanart.jpg'));
      
      // If season and episode specified, update that specific episode
      if (season && episode) {
        const seasonEpisodes = await getSeasonDetails(tmdbId, season, language);
        const epData = seasonEpisodes.find(e => e.episode_number === episode);
        if (epData) {
          const ext = extname(path);
          const epNfo = generateEpisodeNFO(
            show.name,
            tmdbId,
            season,
            episode,
            epData.name,
            epData.air_date,
            epData.overview
          );
          await writeFile(path.replace(ext, '.nfo'), epNfo, 'utf-8');
        }
      } else {
        // No season specified - update ALL seasons and episodes
        console.log(`[refreshMetadata] Updating all seasons for ${showDir}`);
        
        // Scan for season directories
        const entries = await readdir(showDir, { withFileTypes: true });
        for (const entry of entries) {
          if (!entry.isDirectory() || !entry.name.match(/Season\s*\d+/i)) continue;
          
          const seasonPath = join(showDir, entry.name);
          const seasonMatch = entry.name.match(/Season\s*(\d+)/i);
          const seasonNum = seasonMatch ? parseInt(seasonMatch[1]) : 1;
          
          console.log(`[refreshMetadata] Processing season ${seasonNum}`);
          
          // Get season details from TMDB
          const seasonEpisodes = await getSeasonDetails(tmdbId, seasonNum, language);
          
          // Scan for video files in this season
          const files = await readdir(seasonPath, { withFileTypes: true });
          for (const file of files) {
            if (!file.isFile()) continue;
            const ext = extname(file.name).toLowerCase();
            if (!['.mkv', '.mp4', '.m4v', '.avi', '.mov'].includes(ext)) continue;
            
            // Parse episode number from filename
            const epMatch = file.name.match(/S\d+E(\d+)/i) || file.name.match(/E(\d+)/i) || file.name.match(/第\s*(\d+)\s*集/);
            if (!epMatch) continue;
            
            const epNum = parseInt(epMatch[1]);
            const epData = seasonEpisodes.find(e => e.episode_number === epNum);
            
            if (epData) {
              const filePath = join(seasonPath, file.name);
              const epNfo = generateEpisodeNFO(
                show.name,
                tmdbId,
                seasonNum,
                epNum,
                epData.name,
                epData.air_date,
                epData.overview
              );
              await writeFile(filePath.replace(ext, '.nfo'), epNfo, 'utf-8');
              console.log(`[refreshMetadata] Updated NFO for S${seasonNum}E${epNum}`);
            }
          }
        }
      }
      
      return { success: true, message: 'Metadata refreshed' };
    } else {
      const movie = await getMovieDetails(tmdbId, language);
      if (!movie) return { success: false, message: 'Failed to get movie details' };
      
      // Determine if path is a directory or a file
      let movieDir: string;
      let movieFilePath: string | undefined;
      
      const pathStat = await stat(path);
      if (pathStat.isDirectory()) {
        // Path is a movie directory, find the movie file
        movieDir = path;
        const files = await readdir(path, { withFileTypes: true });
        for (const file of files) {
          if (!file.isFile()) continue;
          const ext = extname(file.name).toLowerCase();
          if (['.mkv', '.mp4', '.m4v', '.avi', '.mov'].includes(ext)) {
            movieFilePath = join(path, file.name);
            break;
          }
        }
      } else {
        // Path is a movie file
        movieDir = dirname(path);
        movieFilePath = path;
      }
      
      // Write movie NFO
      const movieNfo = generateMovieNFO(movie);
      if (movieFilePath) {
        const ext = extname(movieFilePath);
        await writeFile(movieFilePath.replace(ext, '.nfo'), movieNfo, 'utf-8');
      } else {
        // Fallback: write to movie.nfo in the directory
        await writeFile(join(movieDir, 'movie.nfo'), movieNfo, 'utf-8');
      }
      
      // Download poster/fanart
      const posterUrl = getPosterUrl(movie.poster_path, 'original');
      const backdropUrl = getBackdropUrl(movie.backdrop_path, 'original');
      if (posterUrl) await downloadImage(posterUrl, join(movieDir, 'poster.jpg'));
      if (backdropUrl) await downloadImage(backdropUrl, join(movieDir, 'fanart.jpg'));
      
      return { success: true, message: 'Metadata refreshed' };
    }
  } catch (error) {
    console.error('Refresh metadata error:', error);
    return { success: false, message: String(error) };
  }
}

// 从 NFO 文件中提取 TMDB ID
async function extractTmdbIdFromNfo(nfoPath: string): Promise<number | undefined> {
  try {
    const content = await Bun.file(nfoPath).text();
    const match = content.match(/<tmdbid>(\d+)<\/tmdbid>/);
    return match ? parseInt(match[1]) : undefined;
  } catch {
    return undefined;
  }
}

// 补刮功能 - 处理已刮削目录中的新文件
export async function supplementTVShow(
  showPath: string,
  language = 'zh-CN'
): Promise<{ success: boolean; message: string; processed: number }> {
  try {
    // 从 tvshow.nfo 获取 TMDB ID
    const tvshowNfoPath = join(showPath, 'tvshow.nfo');
    const tmdbId = await extractTmdbIdFromNfo(tvshowNfoPath);
    
    if (!tmdbId) {
      return { success: false, message: 'Cannot find TMDB ID in tvshow.nfo', processed: 0 };
    }
    
    // 获取剧集详情
    const show = await getTVDetails(tmdbId, language);
    if (!show) {
      return { success: false, message: 'Failed to get show details from TMDB', processed: 0 };
    }
    
    // 扫描季目录
    const entries = await readdir(showPath, { withFileTypes: true });
    let processed = 0;
    
    for (const entry of entries) {
      if (!entry.isDirectory() || !entry.name.match(/Season\s*\d+/i)) continue;
      
      const seasonPath = join(showPath, entry.name);
      const seasonMatch = entry.name.match(/Season\s*(\d+)/i);
      const seasonNum = seasonMatch ? parseInt(seasonMatch[1]) : 1;
      
      // 获取该季的剧集信息
      const seasonEpisodes = await getSeasonDetails(tmdbId, seasonNum, language);
      
      // 扫描季目录中的文件
      const files = await readdir(seasonPath, { withFileTypes: true });
      
      for (const file of files) {
        if (!file.isFile()) continue;
        const ext = extname(file.name).toLowerCase();
        if (!['.mkv', '.mp4', '.m4v', '.avi', '.mov'].includes(ext)) continue;
        
        const filePath = join(seasonPath, file.name);
        const nfoPath = filePath.replace(ext, '.nfo');
        
        // 检查是否已有 NFO
        try {
          await stat(nfoPath);
          continue; // 已有 NFO，跳过
        } catch {
          // 没有 NFO，需要补刮
        }
        
        // 解析文件名获取集数
        const epMatch = file.name.match(/[Ss]\d{1,2}[Ee](\d{1,3})|[Ee](\d{1,3})|第\s*(\d{1,3})\s*[集话話]/);
        if (!epMatch) continue;
        
        const episodeNum = parseInt(epMatch[1] || epMatch[2] || epMatch[3]);
        const epData = seasonEpisodes.find(e => e.episode_number === episodeNum);
        
        if (epData) {
          // 生成 NFO
          const epNfo = generateEpisodeNFO(
            show.name,
            tmdbId,
            seasonNum,
            episodeNum,
            epData.name,
            epData.air_date,
            epData.overview
          );
          await writeFile(nfoPath, epNfo, 'utf-8');
          processed++;
        }
      }
    }
    
    return {
      success: true,
      message: `Supplemented ${processed} episode(s)`,
      processed,
    };
  } catch (error) {
    console.error('Supplement TV show error:', error);
    return { success: false, message: String(error), processed: 0 };
  }
}

// 修复缺失资产
export async function fixMissingAssets(
  kind: 'tv' | 'movie',
  path: string,
  tmdbId: number,
  language = 'zh-CN'
): Promise<{ success: boolean; message: string; fixed: string[] }> {
  const fixed: string[] = [];
  
  try {
    if (kind === 'tv') {
      const show = await getTVDetails(tmdbId, language);
      if (!show) return { success: false, message: 'Failed to get show details', fixed };
      
      const showDir = path;
      
      // 检查并下载海报
      const posterPath = join(showDir, 'poster.jpg');
      try {
        await stat(posterPath);
      } catch {
        const posterUrl = getPosterUrl(show.poster_path, 'original');
        if (posterUrl && await downloadImage(posterUrl, posterPath)) {
          fixed.push('poster.jpg');
        }
      }
      
      // 检查并下载背景图
      const fanartPath = join(showDir, 'fanart.jpg');
      try {
        await stat(fanartPath);
      } catch {
        const backdropUrl = getBackdropUrl(show.backdrop_path, 'original');
        if (backdropUrl && await downloadImage(backdropUrl, fanartPath)) {
          fixed.push('fanart.jpg');
        }
      }
      
      // 检查并生成 tvshow.nfo
      const nfoPath = join(showDir, 'tvshow.nfo');
      try {
        await stat(nfoPath);
      } catch {
        const tvshowNfo = generateTVShowNFO(show);
        await writeFile(nfoPath, tvshowNfo, 'utf-8');
        fixed.push('tvshow.nfo');
      }
      
    } else {
      const movie = await getMovieDetails(tmdbId, language);
      if (!movie) return { success: false, message: 'Failed to get movie details', fixed };
      
      const movieDir = dirname(path);
      
      // 检查并下载海报
      const posterPath = join(movieDir, 'poster.jpg');
      try {
        await stat(posterPath);
      } catch {
        const posterUrl = getPosterUrl(movie.poster_path, 'original');
        if (posterUrl && await downloadImage(posterUrl, posterPath)) {
          fixed.push('poster.jpg');
        }
      }
      
      // 检查并下载背景图
      const fanartPath = join(movieDir, 'fanart.jpg');
      try {
        await stat(fanartPath);
      } catch {
        const backdropUrl = getBackdropUrl(movie.backdrop_path, 'original');
        if (backdropUrl && await downloadImage(backdropUrl, fanartPath)) {
          fixed.push('fanart.jpg');
        }
      }
      
      // 检查并生成 movie.nfo
      const ext = extname(path);
      const nfoPath = path.replace(ext, '.nfo');
      try {
        await stat(nfoPath);
      } catch {
        const movieNfo = generateMovieNFO(movie);
        await writeFile(nfoPath, movieNfo, 'utf-8');
        fixed.push('movie.nfo');
      }
    }
    
    return {
      success: true,
      message: fixed.length > 0 ? `Fixed: ${fixed.join(', ')}` : 'No assets needed fixing',
      fixed,
    };
  } catch (error) {
    console.error('Fix assets error:', error);
    return { success: false, message: String(error), fixed };
  }
}

// 生成预览计划
export async function generatePreviewPlan(
  items: Array<{
    kind: 'tv' | 'movie';
    sourcePath: string;
    showName?: string;
    tmdbId: number;
    season?: number;
    episodes?: Array<{ source: string; episode: number; episodeEnd?: number }>;
  }>,
  language = 'zh-CN'
): Promise<{
  actions: Array<{
    type: 'move' | 'create-nfo' | 'download-poster' | 'create-dir';
    source?: string;
    destination: string;
    willOverwrite: boolean;
  }>;
  impactSummary: {
    filesMoving: number;
    nfoCreating: number;
    nfoOverwriting: number;
    postersDownloading: number;
    directoriesCreating: string[];
  };
}> {
  const actions: Array<{
    type: 'move' | 'create-nfo' | 'download-poster' | 'create-dir';
    source?: string;
    destination: string;
    willOverwrite: boolean;
  }> = [];
  
  const directoriesCreating = new Set<string>();
  let filesMoving = 0;
  let nfoCreating = 0;
  let nfoOverwriting = 0;
  let postersDownloading = 0;
  
  for (const item of items) {
    try {
      if (item.kind === 'tv' && item.showName && item.season && item.episodes) {
        const showDir = join(MEDIA_PATHS.tv, item.showName);
        const seasonDir = join(showDir, `Season ${item.season.toString().padStart(2, '0')}`);
        
        // 检查目录是否需要创建
        try {
          await stat(showDir);
        } catch {
          directoriesCreating.add(showDir);
          actions.push({ type: 'create-dir', destination: showDir, willOverwrite: false });
        }
        
        try {
          await stat(seasonDir);
        } catch {
          directoriesCreating.add(seasonDir);
          actions.push({ type: 'create-dir', destination: seasonDir, willOverwrite: false });
        }
        
        // 检查剧集海报
        const posterDest = join(showDir, 'poster.jpg');
        try {
          await stat(posterDest);
        } catch {
          postersDownloading++;
          actions.push({ type: 'download-poster', destination: posterDest, willOverwrite: false });
        }
        
        // 检查 tvshow.nfo
        const tvshowNfoDest = join(showDir, 'tvshow.nfo');
        let tvshowNfoOverwrite = false;
        try {
          await stat(tvshowNfoDest);
          tvshowNfoOverwrite = true;
          nfoOverwriting++;
        } catch {
          nfoCreating++;
        }
        actions.push({ type: 'create-nfo', destination: tvshowNfoDest, willOverwrite: tvshowNfoOverwrite });
        
        // 检查每集文件
        for (const ep of item.episodes) {
          const ext = extname(ep.source);
          let epStr = `E${ep.episode.toString().padStart(2, '0')}`;
          if (ep.episodeEnd && ep.episodeEnd !== ep.episode) {
            epStr += `E${ep.episodeEnd.toString().padStart(2, '0')}`;
          }
          const destName = `${item.showName} - S${item.season.toString().padStart(2, '0')}${epStr}${ext}`;
          const destPath = join(seasonDir, destName);
          
          let willOverwrite = false;
          try {
            await stat(destPath);
            willOverwrite = true;
          } catch {}
          
          filesMoving++;
          actions.push({ type: 'move', source: ep.source, destination: destPath, willOverwrite });
          
          // 检查集 NFO
          const epNfoDest = destPath.replace(ext, '.nfo');
          let epNfoOverwrite = false;
          try {
            await stat(epNfoDest);
            epNfoOverwrite = true;
            nfoOverwriting++;
          } catch {
            nfoCreating++;
          }
          actions.push({ type: 'create-nfo', destination: epNfoDest, willOverwrite: epNfoOverwrite });
        }
        
      } else if (item.kind === 'movie') {
        const movie = await getMovieDetails(item.tmdbId, language);
        if (!movie) continue;
        
        const year = movie.release_date?.split('-')[0] || '';
        const folderName = year ? `${movie.title} (${year})` : movie.title;
        const movieDir = join(MEDIA_PATHS.movies, folderName);
        
        // 检查目录
        try {
          await stat(movieDir);
        } catch {
          directoriesCreating.add(movieDir);
          actions.push({ type: 'create-dir', destination: movieDir, willOverwrite: false });
        }
        
        // 检查文件
        const ext = extname(item.sourcePath);
        const destPath = join(movieDir, `${folderName}${ext}`);
        let willOverwrite = false;
        try {
          await stat(destPath);
          willOverwrite = true;
        } catch {}
        
        filesMoving++;
        actions.push({ type: 'move', source: item.sourcePath, destination: destPath, willOverwrite });
        
        // 检查 NFO
        const nfoDest = destPath.replace(ext, '.nfo');
        let nfoOverwrite = false;
        try {
          await stat(nfoDest);
          nfoOverwrite = true;
          nfoOverwriting++;
        } catch {
          nfoCreating++;
        }
        actions.push({ type: 'create-nfo', destination: nfoDest, willOverwrite: nfoOverwrite });
        
        // 检查海报
        const posterDest = join(movieDir, 'poster.jpg');
        try {
          await stat(posterDest);
        } catch {
          postersDownloading++;
          actions.push({ type: 'download-poster', destination: posterDest, willOverwrite: false });
        }
      }
    } catch (error) {
      console.error('Preview plan error for item:', item, error);
    }
  }
  
  return {
    actions,
    impactSummary: {
      filesMoving,
      nfoCreating,
      nfoOverwriting,
      postersDownloading,
      directoriesCreating: Array.from(directoriesCreating),
    },
  };
}
